#!/usr/bin/env python
import urllib
import urllib2
import socket
import time
import json
import subprocess
import sys
import multiprocessing
import argparse
import platform
import os

# TODO: add argparse to configure the parameters

# Specify the SSH server you want to use as a port forwarder.
# You should have set up key-based passwordless access already. Otherwise you will be asked for a password.
# as in SSH, you may enter user@host here, too.


class Client():

    def __init__(self, server, custom_hostname=None, ssh_relay=None):
        self.tunnel_up = False
        self.ssh_port = None

        self.ssh_relay = None
        if ssh_relay is not None:
            self.ssh_relay = ssh_relay
        
        self.custom_hostname = None
        if custom_hostname is not None:
            self.custom_hostname = custom_hostname

        if not server.startswith('http://'):
            server = 'http://' + server

        self.server = server
        self.post_url = server + '/add'
        self.ssh_port_url = server + '/request_port'
        

    def ask_for_port(self):
        REQUEST = urllib2.Request(self.ssh_port_url)
        try:
            RESPONSE = urllib2.urlopen(REQUEST)
            return RESPONSE.read()
        except urllib2.URLError:
            print 'Could not connect to ' + self.ssh_port_url
            return None

    def init_tunnel(self, server_address, remote_port, local_port=22):
        """
        Initializes a SSH tunnel
        returns: None or True depending on success
        """
        cmd = ['ssh', '-f', '-N', '-T', '-R'+ str(remote_port) + ':127.0.0.1:' + str(local_port), server_address]
        #ssh -f -N -T -R22222:localhost:22 user@host
        return_value = subprocess.call(cmd)
        if return_value == 0:
            self.tunnel_up = True
            return True

    @staticmethod
    def get_ip():
        """
        Retrieves public ip via ip service
        returns: False or public ip, depending on success
        """
        try:
            public_ip = json.load(urllib2.urlopen('http://jsonip.com'))['ip']
        except urllib2.URLError:
            public_ip = False
            print "Could not connect to ip service"
        return public_ip

    @staticmethod
    def get_uptime():
        """
        Get uptime
        returns: string
        """

        try:
            uptime = subprocess.check_output("uptime").rstrip()
            uptime = uptime.split("up ")[1].split("  ")[0][:-1]
        except OSError:
            uptime = False
        return uptime

    @staticmethod
    def get_free_space():
        directory = os.curdir
        statvfs = os.statvfs(os.curdir)
        free_mb = statvfs.f_frsize * statvfs.f_bfree/1024/1024
        return free_mb

    @staticmethod
    def get_meminfo():
        """
        Retrieve info about memory usage.
        returns: three ints: total, used, free
        """
        mem = False
        try:
            mem = ' '.join(subprocess.check_output(['free', '-m']).splitlines()[1].split()).split()
            mem_total = int(mem[1])
            mem_used = int(mem[2])
            mem_free = mem_total - mem_used
            return mem_total, mem_used, mem_free
        except OSError:
            return 'free -m returned an error'

    @staticmethod
    def get_os():
        """
        Retrieve OS type
        returns: string
        """
        #return sys.platform
        return platform.platform()

    @staticmethod
    def get_cpuinfo():
        """
        Retrieve CPU usage.
        returns: float
        """
        num_cpu = multiprocessing.cpu_count()
        try:
            load = subprocess.check_output('uptime').rstrip()
            load = load.split('age: ')[1].split('  ')[0].split(',')[1]
        except:
            load = False
        if load:
            try:
                load = float(load)
                load = load/num_cpu*100
            except ValueError:
                print 'could not convert cpu to float value. Check uptime format.'
        return load

    def updateloop(self, interval):
        """
        Updates the remote server's DB
        interval: seconds between updates
        """

        def loop():
            VALUES = {
                'ip': self.get_ip(),
                'host': socket.gethostname(),
                'uptime': self.get_uptime(),
                'total memory': str(self.get_meminfo()[0]) + ' MB installed',
                'free memory (MB)': self.get_meminfo()[2],

                'os': self.get_os(),
                'cpu %': self.get_cpuinfo(),
                'update_rate': interval,
                'free space (MB)': self.get_free_space(),
                'cpu type': platform.processor()
            }

            if self.ssh_relay is not None:
                if not self.tunnel_up and self.ssh_port is not None:
                    print 'Tunnel init: port ' + self.ssh_port
                    if self.init_tunnel(self.ssh_relay, self.ssh_port):
                        print 'Tunnel initialized'
                        self.tunnel_up = True
                        VALUES['ssh tunnel entry'] = 'ssh://{}:{}'.format(self.ssh_relay, self.ssh_port)

            if self.custom_hostname is not None:
                VALUES['host'] = self.custom_hostname


            request = urllib2.Request(self.post_url, urllib.urlencode(VALUES))
            try:
                response = urllib2.urlopen(request)
                print 'GOT RESPONSE', response.read()
            except urllib2.URLError:
                print 'Could not connect to ' + self.post_url

            time.sleep(interval)

        while True:
            loop()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Update client')
    parser.add_argument('server', help='pmc server instance')
    parser.add_argument('--hostname', default=None, help='Set custom hostname')
    parser.add_argument('--ssh_relay', default=None, help='Set SSH tunnel server')
    parser.add_argument('--rate', default=360, help='Delay in seconds before next update')
    args = parser.parse_args()
    c = Client(args.server, custom_hostname=args.hostname, ssh_relay=args.ssh_relay)
    c.ssh_port = c.ask_for_port()
    # todo check for int/float on args.rate
    c.updateloop(float(args.rate))

